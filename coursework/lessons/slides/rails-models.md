## Models: how we think about and save information in our app

Rails is often referred to as an "MVC framework" - meaning it's a web framework that organizes code into __M__odels, __V__iews, and __C__ontrollers. We've used views. That's where we keep our HTML. And we've used controllers. That's where we organize our actions - where we run some code _before_ rendering our view and where we decide _which_ view to use.

But what about __models__? Well, each model is a kind of _thing_ we want to save information about in our app. For example, Twitter will save information about users and tweets. Email services will need to save information about users, emails, attachments, and contacts. We'll have a model for each of these that defines which details we want to keep track of in our database.

To better wrap our heads around this, let's walk through a complete, hypothetical model for blog posts.

---

## What's in a post?

The first step to defining a new model is figuring out which information we want to keep track of. Thinking about this, we realize that for each post, we might want to save:

- the title
- the content
- whether it's published or not
- when it was published

And now to give these more Ruby-friendly names, where each word is separated by an underscore:

- `title`
- `content`
- `is_published`
- `published_at`

Great! Now that we know what kind of information we want to keep track of, let's take a tour of some of the most common data types we have available in Rails.

For those who have experience working directly with databases, these general types correspond to more specific types in specific databases. Since implementations vary between databases, the advice I give will not be universally true. Instead, I'll be assuming you're using PostgreSQL, which is a popular and very powerful open source database.

This is also not [a complete list of data types available](http://stackoverflow.com/questions/17918117/rails-4-datatypes#answer-22725797), but rather a simplified list of the most common types.

OK, let's dive in.

<hr>

### `string` and `text`

The `string` type is for shorter text (typically less than 255 characters), such as names and email addresses, while the `text` type is for longer text, such as blog posts or comments.

The main practical difference (assuming you're using PostgreSQL) is that by default, Rails will display an `<input type="text">` for `string` and a `<textarea>` for `text`.

### `boolean`

The `boolean` type is for something that can be either true or false, such as whether a todo item is complete or whether a blog post is published.

### `integer` and `decimal`

The `integer` type is useful for - you guessed it - integers. This may include the number of an item you have in stock, a shoe size, or a counter for how many times a video has been viewed.

The `decimal` type is useful for real numbers, such as for money, longitude/latitude, or exact temperature.

### `date`, `time`, and `datetime`

The `date` type stores a date, the `time` type stores a time, and the `datetime` type stores both together. Pretty self-explanatory.

<hr>

Now let's go back to our data for blog posts and figure out which Rails Rails data types we want to use. , separating any words with underscores and attaching a type via a colon:

- `title` will be shorter text, so the `string` type is probably most appropriate
- `content` will be longer text, so let's use the `text` type there
- `is_published` will only either be `true` or `false`, so `boolean` fits perfectly
- `published_at` will should store the exact _date_ and _time_ that a post was published, so it'll be of type `datetime`

---

## Generating a scaffold for our model

Now we've defined:

- our model,
- which information we want to keep track of for that model,
- and the Rails data types we want to use for each piece of information

So... what next? Believe it or not, the hard part is over! Remember that nifty generator we used to create all the files and lines we'd need for a new controller? Well, we're going to use another generator, this time to create a __scaffold__.

A scaffold is "a full set of model, database migration for that model, controller to manipulate it, views to view and manipulate the data, and a test suite for each of the above."[*](http://guides.rubyonrails.org/command_line.html) We're not using a test suite this time, but we'll get everything else, all with this one terminal command:

``` bash
rails generate scaffold Post title:string content:text is_published:boolean published_at:datetime
```

Notice that for each post attribute, we're attaching a data type with a colon. That colon can be read as "of type" (e.g. our `Post` has a `title` of type `string`, `content` of type `text`, etc).

Now once again, we'll take a tour of the files we just generated to better understand what each one does and how they interact with each other.

---

## Touring the files generated by a scaffold

This is what that command just did for us:

``` output
invoke  active_record
create    db/migrate/20150311150401_create_posts.rb
create    app/models/post.rb
invoke  resource_route
 route    resources :posts
invoke  scaffold_controller
create    app/controllers/posts_controller.rb
invoke    erb
create      app/views/posts
create      app/views/posts/index.html.erb
create      app/views/posts/edit.html.erb
create      app/views/posts/show.html.erb
create      app/views/posts/new.html.erb
create      app/views/posts/_form.html.erb
invoke    helper
create      app/helpers/posts_helper.rb
invoke    jbuilder
create      app/views/posts/index.json.jbuilder
create      app/views/posts/show.json.jbuilder
invoke  assets
invoke    coffee
create      app/assets/javascripts/posts.coffee
invoke    scss
create      app/assets/stylesheets/posts.scss
invoke  scss
create    app/assets/stylesheets/scaffolds.scss
```

Now line by line...

---

### The database migration

``` output
create    db/migrate/20150311150401_create_posts.rb
```

Oh, a new kind of file, in a `db/migrate` folder! The `db`, in this case, stands for _database_ and `migrate` is a fancy term for _making a change_ to our database.

Taking a look inside that file, we'll see something like this:

``` ruby
# db/migrate/20150311150401_create_posts.rb
class CreatePosts < ActiveRecord::Migration
  def change
    create_table :posts do |t|
      t.string :title
      t.text :content
      t.boolean :is_published
      t.datetime :published_at

      t.timestamps null: false
    end
  end
end
```

This __database migration__ describes the changes we'll be making to our database. In this case, we're creating a "posts" __table__ with all the __fields__ we want to store data for.

You'll also notice that Rails added a line for timestamps. This creates two additional fields, `created_at` and `updated_at`, that are automatically filled in by Rails whenever we create or update a __record__.

OK... so a lot of new language here: table, fields, records. Fortunately, it's not as complicated as it sounds. You can think of a table as a spreadsheet, each field as a titled column in that spreadsheet, and each row as a record, like this:

<table class="table table-striped">
  <thead>
    <tr>
      <th colspan="4" class="text-center">POSTS</th>
    </tr>
    <tr>
      <th>title</th>
      <th>content</th>
      <th>is_published</th>
      <th>published_at</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code>"10 cutest cats"</code></td>
      <td><code>"Here are a list of cats..."</code></td>
      <td><code>true</code></td>
      <td><code>2015-12-11 17:43:35</code></td>
    </tr>
    <tr>
      <td><code>"1 weird trick"</code></td>
      <td><code>"All you have to do is..."</code></td>
      <td><code>true</code></td>
      <td><code>2015-12-11 17:45:37</code></td>
    </tr>
    <tr>
      <td><code>"TODO: Think of title"</code></td>
      <td><code>"Super inspiring content..."</code></td>
      <td><code>false</code></td>
      <td><code>2015-12-11 17:47:26</code></td>
    </tr>
  </tbody>
</table>


Also note that while it's not listed here, Rails will also give every record an `id` column, allowing us to uniquely identify each record. It will automatically give our first post an `id` of 1, then second an `id` of 2, etc.

So what Rails generated is pretty good, but let's modify this file a little to better represent how our post should behave. We'll figure out how to modify it by asking this one question: __Will there ever be a case when we the value of one of these fields should be `null` (i.e. _nothing_)?__

Often, the answer is no. In the case of our `title` and `content`, these might be _empty_, but they'll never be _non-existant_. Likewise, `is_published` should never be _nothing_. Rather, it should start out as `false`. As for `published_at`, sometimes that _will be_ nothing. If a post hasn't been published yet, asking the question, "When was it published?" doesn't have an answer.

So for the first three fields, we can better describe them with these two fields: `null: false` and `default: ...`. Check out how I've modified the migrations below:

``` ruby
# db/migrate/20150311150401_create_posts.rb
class CreatePosts < ActiveRecord::Migration
  def change
    create_table :posts do |t|
      t.string   :title,        null: false, default: ''
      t.text     :content,      null: false, default: ''
      t.boolean  :is_published, null: false, default: false
      t.datetime :published_at

      t.timestamps null: false
    end
  end
end
```

Fantastic! _Very_ nice migration.

And finally, for a database migration to actually go in and change our database, we need to run `rake db:migrate` in the terminal. Go ahead and do that now.

---

## The model

``` output
create    app/models/post.rb
```

``` ruby
# app/models/post.rb
class Post < ActiveRecord::Base
end
```

It doesn't look like much. It's an empty `Post` class that _inherits from_ (`<`) `ActiveRecord::Base`. Inheriting from `ActiveRecord::Base` gives our humble `Post` some super powers.

For example, we can now do stuff like this:

``` ruby
Post.create(title: "10 best cats", content: "list of cats...")
```

In fact, let's even try that out. Rails has a special console you can open to play around with your app and its database. To open the Rails console, run:

``` bash
rails console
```

Now try running that `Post.create` command above. You should get back something like this:

``` output
=> #<User:0x007fb01ff10348
 id: 1,
 title: "10 best cats",
 content: "list of cats..."
 is_published: false,
 published_at: nil,
 created_at: Fri, 11 Dec 2015 23:36:17 UTC +00:00,
 updated_at: Fri, 11 Dec 2015 23:36:17 UTC +00:00>
```

To get the title of the last post you created, you could run:

``` ruby
Post.last.title
```

Did you get this?

``` output
=> "10 best cats"
```

Awesome, here are some examples of other

``` ruby
Post.all
# returns a list of all posts

Post.order(published_at: :desc)
# returns a list of all posts, listed in descending order by when they
# were published (i.e. showing most recently published posts first)

Post.count
# returns the number of posts in our database

Post.pluck(:title)
# returns a list of all post titles

Post.first
# returns the first created post

Post.last
# returns the last created post

Post.last.destroy
# deletes the last created post

Post.find_by(title: "10 best cats")
# returns the first post found with a title of "10 best cats"

Post.where(is_published: false)
# returns a list of all unpublished posts
```

You can even chain a bunch of these together! For example, if you gave users the ability to search through blog posts by title, you might use something like this:

``` ruby
Post.
  where(is_published: true).
  where('title ILIKE ?', "%#{params[:search_query]}%").
  order(published_at: :desc)
# returns all the published posts where the value of
# `params[:search_query]` case-insensitively matches the title of
# the post, with results listed in descending order by when they
# were published (i.e. showing most recently published posts first)
```

This is by no means a complete list of methods available, but you can [learn about the rest of them here](http://guides.rubyonrails.org/active_record_querying.html).

---

## The routes

```
route    resources :posts
```

``` ruby
# config/routes.rb
resources :posts
```

What? That's it? This is another line that's more powerful than you might think. If you run `rake routes` in your terminal, you'll see that this one line has single-handedly created _eight_ routes.

```
       Prefix Verb   URI Pattern                   Controller#Action
    recyclers GET    /recyclers(.:format)          recyclers#index
              POST   /recyclers(.:format)          recyclers#create
 new_recycler GET    /recyclers/new(.:format)      recyclers#new
edit_recycler GET    /recyclers/:id/edit(.:format) recyclers#edit
     recycler GET    /recyclers/:id(.:format)      recyclers#show
              PATCH  /recyclers/:id(.:format)      recyclers#update
              PUT    /recyclers/:id(.:format)      recyclers#update
              DELETE /recyclers/:id(.:format)      recyclers#destroy
```

You can [learn more about the command here](http://guides.rubyonrails.org/routing.html#resources-on-the-web).

It's also worth noting that the routes generated by the `resources` command are said to be __RESTful__. REST stands for Representational State Transfer. I know. That doesn't clarify anything, does it? If you want to dive into REST, I recommend checking out [this discussion on Stack Overflow](http://stackoverflow.com/questions/671118/what-exactly-is-restful-programming). I only mention it now because you're likely to hear it a lot.

Otherwise, you can just remember for now that it's The Right Way to build out routes for a model in your database. If you're not using the `resources` command for a model, you're probably doing it wrong.

---

## The controller

```
create    app/controllers/posts_controller.rb
```

Wow, we have a whopping 75 lines generated for us in our new posts controller. That's too much to even show here, so go check it out now in your own text editor.

This file defines all the actions that our routes point to. And guess what? We get not only HTML endpoints, but also JSON endpoints. You hear that? We just got a free API! If that doesn't mean anything to you, that's OK. It will when it matters.

A lot of other stuff is going on this file too, but don't worry, but guess what? You don't have to understand it all yet.

---

### The HTML views

```
create      app/views/posts
create      app/views/posts/index.html.erb
create      app/views/posts/edit.html.erb
create      app/views/posts/show.html.erb
create      app/views/posts/new.html.erb
create      app/views/posts/_form.html.erb
```

We have a view for the:

- index action, to list posts
- edit action, to show a form for a single, existing post
- show action, to show information for a single post
- new action, to show a form for a single, new post

And we also have a form __partial__, indicated by the leading underscore. A partial contains view code that's extracted out of action views, either to DRY up the code or to make it more modular. In this case, the `_form.html.erb` partial is used in the views for both the `new` and `edit` actions.

---

### The JSON views

```
create      app/views/posts/index.json.jbuilder
create      app/views/posts/show.json.jbuilder
```

These two files set up what JSON we show for the `index` and `show` actions. They're in a new format you haven't seen before, called [`jbuilder`](https://github.com/rails/jbuilder). You don't have to worry too much about it for now.

As for JSON, just know that it's a special format that webapps often use to talk to _each other_ and to _themselves_.

---

## The helpers

```
create      app/helpers/posts_helper.rb
```

Just like the helper that was created for our static controller, it starts out empty.

---

## The assets

```
invoke  assets
invoke    coffee
create      app/assets/javascripts/posts.coffee
invoke    scss
create      app/assets/stylesheets/posts.scss
invoke  scss
create    app/assets/stylesheets/scaffolds.scss
```

Once again, we have a file for JavaScript and SCSS for posts, but we also have one other file: `scaffolds.scss`. This file just provides some basic styling to make your app look a little less ugly by default. Once I start adding my own styling, I always delete it.

---

## Tweaking your app

Launch your app once again with `rails server` and try to add, edit, and delete recyclers at `localhost:3000/recyclers`. It should be working pretty well, except for 2 glaring problems:

1. If a visitor went to the homepage, they wouldn't have any way of knowing that we even _have_ a page listing recyclers. We need to link to it in our navigation menu.
2. Right now, it's possible to enter a recycler with a blank name, a phone number just containing "blah", or a website that doesn't exist. That's yucky.

### Adding a link to recyclers

Just like we did for the last skill, we're going to add a link to the recyclers page. We can find out the prefix for it with `rake routes`.

```
   Prefix Verb   URI Pattern                   Controller#Action
recyclers GET    /recyclers(.:format)          recyclers#index
```

It looks like the prefix is `recyclers`, which means the URL helper we'll use is `recyclers_path`. We can add that to our navigation menu with something like:

``` erb
<%= link_to 'Recyclers Directory', recyclers_path %>
```

### Adding form validations

Form validations prevent records from being saved in a state that we don't like. They can even display nice error messages to users, so that they know exactly what they need to fix before their form can be submitted. __Validations go in our model file, so in this case: `models/recycler.rb`.__

#### Making sure `name` and `address` aren't blank

Some validations are simple. If we just want to make sure a `name` and `address` are always entered, we can validate that they are present with:

``` ruby
validates_presence_of :name, :address
```

#### Making sure the phone number is in the format 123-456-7890

Other times, [a little bit of regex](http://rubular.com/r/55dmch9dlC) can be useful. If you've never used regex (i.e. regular expressions) before, they allow you to match text to a pattern. In this case, we're looking for 3 digits, then 3 more digits, then 4 digits, each group separated by a hyphen.

``` ruby
validates_format_of :phone, with: /\A\d{3}-\d{3}-\d{4}\z/, message: "isn't a correctly formatted phone number: e.g. 123-456-7890", allow_blank: true
```

We're also specifying a message to show the user if the validation fails and allowing the user to submit the form with a blank phone number, if they don't have one for that recycler.

#### Making sure the website is a valid web address (1)

Sometimes we have to write custom validation methods that do a little bit more work, like checking that the string actually contains a valid web address (with some much more complicated regex), then actually visiting the website and checking the response code for either `HTTPSuccess` (200 range) or `HTTPRedirection` (300 range).

If this seems intimidating, don't worry. So many people use Rails that most of the time, if you want to do a more complicated validation, you'll be able to google something like "rails validate that website is valid" and you'll find plenty of decent solutions.

Check the next slide for the solution I typically use for this problem, which I personally feel is better than anything I've seen online so far.

#### Making sure the website is a valid web address (2)

``` ruby
before_validation :format_website
validate :valid_website

def format_website
  self.website = "http://#{website}" unless website.blank? || website[/^https?/]
end

def valid_website
  return if website.blank?
  if /(\A(http|https):\/\/[a-z0-9]+([\-\.]{1}[a-z0-9]+)*\.[a-z]{2,5}(([0-9]{1,5})?\/.*)?\z)/ix =~ website
    begin # check header response
      response = Net::HTTP.get_response URI.parse(website)
      return if response.kind_of?(Net::HTTPSuccess) || response.kind_of?(Net::HTTPRedirection)
      message = "doesn't appear to be a page on #{response.uri.host} (#{response.code}: #{response.msg})"
    rescue # Recover on DNS failures
      message = "doesn't seem to exist on the web"
    end
  end
  message ||= "isn't a valid web address"
  errors.add(:website, message)
end
```

---

## Deploying to Heroku

The only thing we have to keep in mind for Heroku is that just like we had to run a command to migrate our database locally, we'll have to run a command to migrate our database after we desploy. You can run commands on your Heroku app with `heroku run`. In this case, we'll use:

``` bash
heroku run rake db:migrate
```
